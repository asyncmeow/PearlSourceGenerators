using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using PearlSourceGenerators.Utility;

namespace PearlSourceGenerators;

/// <summary>
/// A source generator that adds a pair of attributes for lazy dependency injection and auto-generates properties for
/// requesting lazy DI instances.
/// </summary>
[Generator]
public class LazyDependencyInjectionSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "Generators";
    private const string ClassAttribute = "LazyDependencyInjectionAttribute";
    private const string FieldAttribute = "LazyDependencyAttribute";
    
    private const string Attributes = $$"""
                                        // <auto-generated/>
                                        namespace {{Namespace}}
                                        {
                                            [System.AttributeUsage(System.AttributeTargets.Class)]
                                            public class {{ClassAttribute}} : System.Attribute
                                            {
                                            }
                                        
                                            [System.AttributeUsage(System.AttributeTargets.Field)]
                                            public class {{FieldAttribute}} : System.Attribute
                                            {
                                            }
                                        }
                                        """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => 
            ctx.AddSource("Attributes.g.cs",
                SourceText.From(Attributes, Encoding.UTF8)));
        
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.attributesFound)
            .Select((t, _) => t.Item1);
        
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static (ClassDeclarationSyntax, bool attributesFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        // check if the class has the attribute we expect
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var hasClassAttr = classDeclarationSyntax.HasAttribute(context, $"{Namespace}.{ClassAttribute}");

        // check if any fields have the attribute we expect
        var hasFieldAttr = classDeclarationSyntax.AnyClassMembersHave<FieldDeclarationSyntax>(context,
                $"{Namespace}.{FieldAttribute}");
        
        return (classDeclarationSyntax, hasClassAttr && hasFieldAttr);
    }

    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        foreach (var classDecl in classDeclarations)
        {
            // the semantic model of a class lets us retrieve its metadata easier
            var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
            
            // symbols let us get compile-time info like types
            if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            // 'identifier' = token of the node, in this case, the name of the class
            var className = classDecl.Identifier.Text;

            var fields = classSymbol.GetMembers()
                .OfType<IFieldSymbol>()
                .ToList();

            var propertyTexts = fields.Select(field => 
                GeneratePropertyFromField(field))
                .OfType<string>() // removes null strings from the list
                .ToList();

            var source = GenerateClassSource(className, namespaceName, propertyTexts);
            context.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    // for each field in the class:
    // - check if it has the field attribute we expect (skip the field if not)
    // - reformat the name - _someName -> SomeName
    // - get the full namespaced type name - SomeService -> SomeNamespace.SomeService
    // - generate a new property to get it -
    //      public SomeNamespace.SomeService SomeName => _someName ??= _provider.GetRequiredService<...>();
    private static string? GeneratePropertyFromField(IFieldSymbol field)
    {
        // attribute check
        var hasAttribute = false;
        var attributes = field.GetAttributes();
        foreach (var attribute in attributes)
        {
            if (attribute.AttributeClass == null)
                continue;
            var attributeClass =
                $"{attribute.AttributeClass.ContainingNamespace}.{attribute.AttributeClass.Name}";
            if (attributeClass != $"{Namespace}.{FieldAttribute}")
                continue;
            hasAttribute = true;
        }

        if (!hasAttribute)
            return null;
                
        // name reformatting
        var name = field.Name;
        if (name.StartsWith("_"))
            name = name.Substring(1);
        name = name[0].ToString().ToUpper() + name.Substring(1);
                
        // type fetching
        var type = field.Type;
        var typeNamespace = type.ContainingNamespace.ToDisplayString();
        var typeName = type.Name;
        var typeFullName = $"{typeNamespace}.{typeName}";
        if (typeFullName.EndsWith("?"))
            typeFullName = typeFullName.Substring(0, typeFullName.Length - 1);
                
        // resulting property text
        return $"public {typeFullName} {name} => {field.Name} ??= _provider.GetRequiredService<{typeFullName}>();";
    }

    private static string GenerateClassSource(string className, string namespaceName, IEnumerable<string> propertyTexts)
    {
        return $$"""
                 // <auto-generated/>
                 using System;
                 using Microsoft.Extensions.DependencyInjection;
                 namespace {{namespaceName}};
                 partial class {{className}}
                 {
                     private IServiceProvider _provider;
                     public {{className}}(IServiceProvider provider) {
                         _provider = provider;
                     }
                 {{string.Join("\r\n", propertyTexts.Select(s => $"    {s}"))}}
                 }
                 """;
    }
}
